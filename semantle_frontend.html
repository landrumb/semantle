<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        input, button { padding: 10px; margin: 5px; }
        .guess { margin: 10px 0; cursor: pointer; color: black; text-decoration: underline; }
        .latest-guess { font-weight: bold; color: red; }
        .highlight-container { background-color: lightgray; padding: 10px; margin: 10px auto; display: inline-block; }
        .neighbors { margin-top: 10px; }
        .neighbor { cursor: pointer; text-decoration: underline; display: inline-block; margin: 5px; }
        .neighbor.guessed { color: red; }
        .neighbor.not-guessed { color: green; }
    </style>
</head>
<body>
    <h1>Search Graph Semantle</h1>
    <button onclick="startGame()">Start New Game</button>
    <input type="text" id="guessInput" placeholder="Enter a word">
    <button onclick="makeGuess()">Guess</button>
    
    <div id="neighbors"></div>
    <div id="highlightedGuesses"></div>
    <div id="guesses"></div>

    <script>
        window.API_BASE_URL = "<%= process.env.API_BASE_URL %>" || "https://semantle-graph.onrender.com";
    </script>

    <script>
        let targetWord = "";
        let guesses = [];
        // Cache for storing similarity data: guessDataCache[word] = { similarity, rank }
        let guessDataCache = {};
        // Cache for storing neighbor lists: neighborsCache[word] = [neighbor1, neighbor2, ...]
        let neighborsCache = {};

        function saveState() {
            localStorage.setItem("targetWord", targetWord);
            localStorage.setItem("guesses", JSON.stringify(guesses));
            localStorage.setItem("guessDataCache", JSON.stringify(guessDataCache));
            localStorage.setItem("neighborsCache", JSON.stringify(neighborsCache));
        }

        function loadState() {
            targetWord = localStorage.getItem("targetWord") || "";
            guesses = JSON.parse(localStorage.getItem("guesses")) || [];
            guessDataCache = JSON.parse(localStorage.getItem("guessDataCache")) || {};
            neighborsCache = JSON.parse(localStorage.getItem("neighborsCache")) || {};
            if (!targetWord) {
                startGame();
            } else {
                renderGuesses();
            }
        }

        async function startGame() {
            let res = await fetch(`${window.API_BASE_URL}/get_vocab`);
            let data = await res.json();
            let vocab = data.vocab;
            targetWord = vocab[Math.floor(Math.random() * vocab.length)];
            guesses = [];
            guessDataCache = {};
            neighborsCache = {};
            saveState();
            document.getElementById("guesses").innerHTML = "";
            document.getElementById("highlightedGuesses").innerHTML = "";
            document.getElementById("neighbors").innerHTML = "";
            alert("New game started! A word has been chosen.");
        }

        async function makeGuess(word = null) {
            let guessWord = word || document.getElementById("guessInput").value.toLowerCase();
            if (!guessWord) return alert("Enter a word!");
            if (guesses.some(g => g.word === guessWord)) return alert("You already guessed this word!");

            // If in cache, skip re-fetch
            let similarity, rank;
            if (guessDataCache[guessWord]) {
                similarity = guessDataCache[guessWord].similarity;
                rank = guessDataCache[guessWord].rank;
            } else {
                let simRes = await fetch(`${window.API_BASE_URL}/similarity`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word1: [targetWord], word2: [guessWord] })
                });
                let simData = await simRes.json();
                if (simData.error) {
                    alert(simData.error);
                    return;
                }
                similarity = simData.similarities[0][0]; 

                let topKRes = await fetch(`${window.API_BASE_URL}/top_k`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word: guessWord, k: 1000 })
                });
                let topKData = await topKRes.json();
                rank = topKData.top_words.indexOf(guessWord);

                guessDataCache[guessWord] = { similarity, rank };
            }

            guesses.push({ word: guessWord, similarity, rank });
            guesses.sort((a, b) => b.similarity - a.similarity);
            saveState();
            renderGuesses();
            refreshNeighborColors();

            if (guessWord === targetWord) alert(`ðŸŽ‰ You guessed the word! It was "${targetWord}"`);

            // Prefetch neighbors in the background (for faster future display)
            prefetchNeighbors(guessWord);
        }

        function renderGuesses() {
            let topGuesses = guesses.filter(g => g.rank > 0 && g.rank <= 1000);
            let otherGuesses = guesses.filter(g => g.rank === 0 || g.rank > 1000);
            
            let highlightedGuesses = topGuesses.length > 0
                ? `<div class="highlight-container">` +
                  topGuesses.map((g, i) =>
                    `<div class="guess" onclick="fetchNeighbors('${g.word}')">${i + 1}. <b>${g.word}</b> - Similarity: ${g.similarity.toFixed(4)} (Rank: ${g.rank})</div>`
                  ).join("") +
                  `</div>`
                : "";

            let otherGuessesHtml = otherGuesses.map((g, i) =>
                `<div class="guess" onclick="fetchNeighbors('${g.word}')">${i + 1 + topGuesses.length}. <b>${g.word}</b> - Similarity: ${g.similarity.toFixed(4)}</div>`
            ).join("");
            
            document.getElementById("highlightedGuesses").innerHTML = highlightedGuesses;
            document.getElementById("guesses").innerHTML = otherGuessesHtml;
        }

        // Fetch neighbors in the background, store them in neighborsCache
        async function prefetchNeighbors(word) {
            // If we already have neighbors for this word, skip
            if (neighborsCache[word]) return;
            try {
                let res = await fetch(`${window.API_BASE_URL}/neighbors`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word })
                });
                let data = await res.json();
                if (!data.error) {
                    neighborsCache[word] = data.neighbors;
                    saveState();
                }
            } catch (e) {
                // ignore
            }
        }

        // Show neighbors in UI, then prefetch their similarities
        async function fetchNeighbors(word) {
            // If neighbors already cached, render immediately
            if (neighborsCache[word]) {
                renderNeighbors(word, neighborsCache[word]);
                // Prefetch similarities in background
                prefetchNeighborSimilarities(neighborsCache[word]);
            } else {
                // Otherwise, fetch fresh neighbors, show them, then prefetch similarities
                try {
                    let res = await fetch(`${window.API_BASE_URL}/neighbors`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ word })
                    });
                    let data = await res.json();
                    if (data.error) {
                        alert(data.error);
                        return;
                    }
                    neighborsCache[word] = data.neighbors;
                    renderNeighbors(word, data.neighbors);
                    saveState();
                    prefetchNeighborSimilarities(data.neighbors);
                } catch (e) {
                    alert("Error fetching neighbors: " + e);
                }
            }
        }

        function renderNeighbors(word, neighborList) {
            // Render immediately
            document.getElementById("neighbors").innerHTML =
                `<div class="neighbors">Neighbors of <b>${word}</b>: ` +
                neighborList.map(n => `<span class="neighbor" id="neighbor-${n}" onclick="makeGuess('${n}')">${n}</span>`).join(" ") +
                `</div>`;
            refreshNeighborColors();
        }

        async function prefetchNeighborSimilarities(neighborList) {
            // Filter out neighbors that have already been fetched
            let newNeighbors = neighborList.filter(n => !guessDataCache[n]);
        
            if (newNeighbors.length === 0) return;
        
            try {
                let simRes = await fetch(`${window.API_BASE_URL}/similarity`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word1: [targetWord], word2: newNeighbors })
                });
        
                let simData = await simRes.json();
                if (simData.error) return;
        
                // Process the similarity matrix (1 row, multiple columns)
                let similarities = simData.similarities[0];
        
                // Fetch ranks in one batch
                let topKRes = await fetch(`${window.API_BASE_URL}/top_k`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ word: newNeighbors, k: 1000 })
                });
        
                let topKData = await topKRes.json();
        
                // Store results in cache
                newNeighbors.forEach((word, idx) => {
                    let rank = topKData.top_words.indexOf(word);
                    guessDataCache[word] = { similarity: similarities[idx], rank };
                });
        
                saveState();
            } catch (e) {
                console.error("Error prefetching similarities:", e);
            }
        }

        function refreshNeighborColors() {
            document.querySelectorAll(".neighbor").forEach(neighbor => {
                let w = neighbor.textContent;
                neighbor.className = "neighbor " + (guesses.some(g => g.word === w) ? "guessed" : "not-guessed");
            });
        }

        document.getElementById("guessInput").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                makeGuess();
            }
        });

        loadState();
    </script>
</body>
</html>